<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>schulcloud-server documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../../images/favicon.ico">
	      <link rel="stylesheet" href="../../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../../" class="navbar-brand">schulcloud-server documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content additional-page">
                   <div class="content-data">














                   




<h1 id="architecture-mapping-to-code">Architecture mapping to Code</h1>
<h2 id="conventions">Conventions</h2>
<h3 id="file-structure">File structure</h3>
<p>The server app located in <code>/apps/server</code> is structured like. Beside each ts-file, a test file _.spec.ts has to be added for unit tests (hidden for simplification). Use index.ts files that combine a folders content and export all files from within of the folder using <code>export _ from &#39;./file&#39;</code> where this makes sense. When there are naming conflicts, use more specific names and correct concepts. Think about not to create sub-folders, when only one concept exist.</p>
<div><pre class="line-numbers"><code class="language-js">src/ // sourcecode &amp; unit tests
    - config/  // for global definitions
    - modules/ // for your NestJS modules
        - [module] // where [module] could be like user, homework, school
            - entity/
                - &lt;entity&gt;.entity.ts // (where &lt;entity&gt; might be a user, news, ... owned by the module) exports entity class &amp; document type
                - &lt;related-info&gt;.entity.ts // where related-info is a partial of another entity used in the entity above
                - index.ts // exports all entities
            - controller/ // where controllers define the api
                - dto/ // dto&#39;s define api in/out types as a class with annotations
                    - &lt;action-&gt;[param|query].ts // (like create-user-param.ts or pagination.query)
                    - &lt;data-&gt;[response].ts // (like create-user-response.ts)
                    - index.ts // exports all dto&#39;s
                - &lt;module&gt;.controller.ts // defines rest api, references main service file
                - &lt;other&gt;.controller.ts // think about a new module when require multiple controllers :)
            - repo/ // repositories take care to load/persist/... entities
                - schema/ // contains schema imports from legacy app or new definitions (might be replaced by OR mapper)
                    - &lt;entity&gt;.schema.ts // exports (legacy-) mongoose schemas
                - &lt;entity&gt;.repo.ts // where entity might be user, news, school
            - service/ // for technical dependencies (libraries, infrastructure layer concerns)
                - &lt;module&gt;.service.ts // the modules main service file, might be exported for other modules
                - &lt;other&gt;.service.ts // use services not for features
            - mapper/
                - &lt;entity&gt;.mapper.ts // mapper for a domain entity, should contain mapDomainToResponse and mapFooToDomain
            - uc/ // preferred for features
                - &lt;login-user&gt;.uc.ts // one file per single use case (use a long name)
            - &lt;module&gt;.module.ts // DI instructions to build the module
    - shared/ // reused stuff without module ownership
        - core/ // shared concepts (decorators, pipes, guards, errors, ...) folders might be added
        - domain // (abstract) domain base entities which will be extended in the modules
        - util/ // helpers, tools, utils can be located here (but find a better name)
test/ // e2e tests against controllers should use same folder names like controllers
</code></pre></div><p>For concepts (see <a href="https://docs.nestjs.com/first-steps">https://docs.nestjs.com/first-steps</a>) of NestJS put implementations in shared/core. You might use shared/utils for own solutions, assume TextUtils but when it contains text validators, move it better to shared/validators/text.validator.ts before merge. The core concepts of NestJS can be extended with ours (like repo).</p>
<h3 id="file-naming-conventions">File naming conventions</h3>
<p>In TypeScript files: for Classes we use <code>PascalCase</code> (names start with uppercase letter), variables use lowercase for the first letter <code>camelCase</code>.</p>
<p>When assigning names, they may end with a concept name:</p>
<ul>
<li><p>A Concept might be a known term which is widely used. Samples from NestJS: Controller, Provider, Module, Middleware, Exception, Pipe, Guard, Interceptor.</p>
</li>
<li><p>Beside we have own concepts like comparator, validator (generic ones should not be part of a modules (and located in shared folder btw) or repo, use-case which might be owned by a module.</p>
</li>
</ul>
<p>In file names, we use lowercase and minus in the beginning and end with <code>.&lt;concept&gt;.ts</code></p>
<h4 id="samples">Samples</h4>
<table class="table table-bordered compodoc-table">
<thead>
<tr>
<th>File name</th>
<th>Class name</th>
<th>Concept</th>
<th>Location</th>
</tr>
</thead>
<tbody>
<tr>
<td>login-user.uc.ts</td>
<td>LoginUserUc</td>
<td>use case</td>
<td>module/uc</td>
</tr>
<tr>
<td>text.validator.ts</td>
<td>TextValidator</td>
<td>validator</td>
<td>shared/validators</td>
</tr>
<tr>
<td>user.repo.ts</td>
<td>UserRepo</td>
<td>repository</td>
<td>module/repo</td>
</tr>
<tr>
<td>parse-object-id.pipe.ts</td>
<td>ParseObjectIdPipe</td>
<td>pipe</td>
<td>shared/pipes</td>
</tr>
</tbody>
</table>
<h2 id="components">Components</h2>
<p>Components are defined as NestJS <a href="https://docs.nestjs.com/modules">Modules</a>. </p>
<h3 id="communication-between-components">Communication between components</h3>
<p>To access other modules services, it can be injected anywhere. The usage is allowed only, when the module which owns that service has exported it in the modules definition.</p>
<div><pre class="line-numbers"><code class="language-TypeScript">// modules/feathers/feathers-service.provider.ts
// modules/feathers/feathers.module.ts
&#64;Module({
    providers: [FeathersServiceProvider],
    exports: [FeathersServiceProvider],
})
export class FeathersModule {}
</code></pre></div><p>The feathers module is used to handle how the application is using legacy services, when access them, inject the <code>FeathersServiceProvider</code> but in your module definition, import the <code>FeathersModule</code>.</p>
<div><pre class="line-numbers"><code class="language-TypeScript">// your module, here modules/authorization/authorization.module.ts
&#64;Module({
    imports: [FeathersModule], // here import the services module
    // providers: [AuthorizationService, FeathersAuthProvider],
    // exports: [AuthorizationService],
})
export class AuthorizationModule {}

// inside of your service, here feathers-auth.provider.ts
&#64;Injectable()
export class FeathersAuthProvider {

    // inject the service in constructor
    constructor(private feathersServiceProvider: FeathersServiceProvider) {}

    // ...

    async getUserTargetPermissions(
        // ...
    ): Promise&lt;string[]&gt; {
        const service = this.feathersServiceProvider.getService(`path`);
        const result = await service.get(...)
        // ...
        return result;
    }
</code></pre></div><h3 id="access-legacy-code">Access legacy Code</h3>
<p>Use the feathers module introduced above to get access to legacy services.</p>
<p>It is important to introduce strong typing like it happened above in the FeathersAuthProvider. While the <code>FeathersServiceProvider</code> from the feathers module, has only an abstract implementation for all services, add a concrete service inside your module for a specific feathers-service, like above in <code>FeathersAuthProvider</code>.</p>
<h2 id="layered-architecture">Layered Architecture</h2>
<p>The different layers use separately defined objects that must be mapped when crossing layers.</p>
<ul>
<li>Never export entities through the service layer without DTO-mapping which is defined in the controller</li>
<li>Concepts owned by a layer must not be shared with other layers</li>
</ul>
<p><img src="../../assets/object-ownership.svg" alt="" class="img-responsive"></p>
<p>Further reading: <a href="https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/">https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/</a></p>
<h3 id="service-layer">Service Layer</h3>
<p>A modules service layer is defined within of <a href="https://docs.nestjs.com/controllers">controllers</a>.</p>
<p>The main responsibilities of a controller is to define the REST API interface as openAPI specification and map DTO&#39;s to match the logic layers interfaces.</p>
<div><pre class="line-numbers"><code class="language-TypeScript">    &#64;Post()
    async create(&#64;CurrentUser() currentUser: ICurrentUser, &#64;Body() params: CreateNewsParams): Promise&lt;NewsResponse&gt; {
        const news = await this.newsUc.create(
            currentUser.userId,
            currentUser.schoolId,
            NewsMapper.mapCreateNewsToDomain(params)
        );
        const dto = NewsMapper.mapToResponse(news);
        return dto;
    }</code></pre></div><h4 id="jwt-authentication">JWT-Authentication</h4>
<p>For <strong>authentication</strong>, use <a href="https://docs.nestjs.com/guards">guards</a> like JwtAuthGuard. It can be applied to a whole controller or a single controller method only. Then, <a href="/apps/server/src/modules/authentication/interface/jwt-payload.ts">ICurrentUser</a> can be injected using the <code>@CurrentUser()</code> decorator.</p>
<h4 id="validation">Validation</h4>
<p>Global settings of the core-module ensure <strong>request/response validation</strong> against the api definition. Simple input types might additionally use a custom <a href="https://docs.nestjs.com/pipes">pipe</a> while for complex types injected as query/body are validated by default when parsed as DTO class.</p>
<h4 id="file-naming">File naming</h4>
<p>Complex input DTOs are defined like [create-news].param.ts (class-name: CreateNewsParam) or [pagination].query.ts (class-name: PaginationQuery)</p>
<p>When DTO&#39;s are shared between multiple modules, locate them in the layer-related shared folder.</p>
<blockquote>
<p><strong>Security:</strong> When exporting data, internal entities must be mapped to a response DTO class named like [news].response.dto. The mapping ensures which data of internal entities are exported.</p>
</blockquote>
<h4 id="openapi-specification">openAPI specification</h4>
<p>Defining the request/response DTOs in a controller will define the openAPI specification automatically. Additional <a href="https://docs.nestjs.com/techniques/validation">validation rules</a> and <a href="https://docs.nestjs.com/openapi/decorators">openAPI definitions</a> can be added using decorators. For simplification, openAPI decorators should define a type and if a property is required, while additional decorators can be used from class-validator to validate content.</p>
<h4 id="mapping">Mapping</h4>
<p>It is forbidden, to directly pass a DTO to a use-case or return an Entity (or other use-case result) via REST. In-between a mapper must transform the given data, to protect the logic layer from outside implications.</p>
<p>The use of a mapper gives us the guarantee, that</p>
<ul>
<li>no additional data beside the known properties is published.<ul>
<li>A plain object might contain more properties than defined in TS-interfaces.
Sample: All school properties are published while only name &amp; id are intended to be published.</li>
</ul>
</li>
<li>the API definition is complete</li>
</ul>
<h3 id="logic-domain--layer">Logic (Domain-) Layer</h3>
<p>The domain layer assumes a kind of higher-level policy that everything else relies on (<a href="https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/">Source</a>).</p>
<blockquote>
<p>This means, a controller or a repository must fit this layer.
Specific goals of a repository, like query optimization must not be a transparent part of the repository only.</p>
</blockquote>
<h3 id="data-access-layer">Data access Layer</h3>
<p>The data access layer consists of repositories. A repository takes care to persist domain entities defined in the business layer. As we use decorators in entities to define how they are persisted, they are used in this layer too. The repository does not need to map entities like in the presentation layer as it maps data from/to an external system into the domain and to be used from/in the business layer.</p>
<blockquote>
<p>It&#39;s not the task of the business layer to fit a repository. A respository should give the logic layer the ability to persist/make available what is defined in the logic layer. The domain model must be independent from a repository (See Clean Architecture).</p>
</blockquote>
<p>Specific concepts from within of this layer must be hidden for the business layer like database queries, protocol specifics, mapping to data layer. Others like putting multiple persistence rules into transactions is part of the domain layer (while how a transaction is implemented, then is part of the data access layer).</p>
<p>Logic should not be part of a repository, use logic layer instead.</p>

                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 2;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'additional-page';
            var COMPODOC_CURRENT_PAGE_URL = 'architecture-mapping-to-code.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../../js/libs/custom-elements.min.js"></script>
       <script src="../../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../../js/menu-wc.js" defer></script>

       <script src="../../js/libs/bootstrap-native.js"></script>

       <script src="../../js/libs/es6-shim.min.js"></script>
       <script src="../../js/libs/EventDispatcher.js"></script>
       <script src="../../js/libs/promise.min.js"></script>
       <script src="../../js/libs/zepto.min.js"></script>

       <script src="../../js/compodoc.js"></script>

       <script src="../../js/tabs.js"></script>
       <script src="../../js/menu.js"></script>
       <script src="../../js/libs/clipboard.min.js"></script>
       <script src="../../js/libs/prism.js"></script>
       <script src="../../js/sourceCode.js"></script>
          <script src="../../js/search/search.js"></script>
          <script src="../../js/search/lunr.min.js"></script>
          <script src="../../js/search/search-lunr.js"></script>
          <script src="../../js/search/search_index.js"></script>
       <script src="../../js/lazy-load-graphs.js"></script>


    </body>
</html>
